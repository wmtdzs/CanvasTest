<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>绘制路径</title>
    <link rel="stylesheet" href="../common/css/common.css">
    <link rel="stylesheet" href="../common/css/prism.css">
</head>
<body>
    <div class="container">
        <!-- 绘制路径 -->
        <div>
            <h3><span class="tag-line" data-code="绘制路径"></span></h3>
            <p class="row">
                图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。
                一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。
            </p>
            <ol>
                <li>首先，需要创建路径起始点</li>
                <li>然后使用画图命令画出路径</li>
                <li>之后把路径封闭</li>
                <li>一旦路径生成，就能通过描边或填充路径区域来渲染图形</li>
            </ol>
            <p class="row">以下是所要用到的函数：</p>
            <p>
                <span class="tag-line normal" data-code="beginPath()"></span><br>
                <span>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径</span>
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="closePath()"></span><br>
                <span>闭合路径之后图形绘制命令又重新指向到上下文中</span>
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="stroke()"></span><br>
                <span>通过线条来绘制图形轮廓</span>
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="fill()"></span><br>
                <span>通过填充路径的内容区域生成实心的图形</span>
            </p>
            <p class="row">
                生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在
                一个列表中，所有的子路径(线、弧形、等等)构成图形。而每次这个方法调用后，列表清空
                重置，然后我们就可以重新绘制新的图形。
            </p>
            <div class="warning">
                <p>
                    注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，第一条路径构造命令通常被视为是moveTo()，
                    无论实际上是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。
                </p>
            </div>
            <p class="row">第二步就是调用函数指定绘制路径</p>
            <p class="row">
                第三，就是闭合路径closePath()，不是必须的。这个方法会通过绘制一条从当前点到开始点的直线来别和图形。
                如果图形是已经闭合了的，即当前点位开始点，该函数什么也不做。
            </p>
            <div class="warning">
                <p>
                    注意：当调用fill()函数时，所有没有闭合的形状都会自动闭合，所以不需要调用closePath()函数。
                    但是调用stroke()时不会自动闭合。
                </p>
            </div>
        </div>

        <!-- 绘制一个三角形 -->
        <div>
            <h4><span class="sub-title">绘制一个三角形</span></h4>
            <p class="row">绘制一个三角形，代码如下：</p>
            <pre class="code line-numbers language-javascript">
                <code>function draw() {</code>
                <code>  var canvas = document.getElementById('canvas');</code>
                <code>  if (canvas.getContext) {</code>
                <code>      var ctx = canvas.getContext('2d');</code>
                <code>      ctx.beginPath();</code>
                <code>      ctx.moveTo(75, 50);</code>
                <code>      ctx.lineTo(100, 75);</code>
                <code>      ctx.lineTo(100, 25);</code>
                <code>      ctx.fill();</code>
                <code>  }</code>
                <code>}</code>
            </pre>
            <canvas id="triangle" width="150" height="150"></canvas>
        </div>

        <!-- 移动笔触 -->
        <div>
            <h4><span class="sub-title">移动笔触</span></h4>
            <p class="row">
                一个非常有用的函数，而这个函数实际上并不能画出任何东西，也是上面所描述的路径列表的一部分，
                这个函数就是moveTo(x, y)。或者你可以想象一下在纸上作业，一支钢笔或者铅笔的笔尖从一个点到
                另一个店的移动过程。
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="moveTo(x, y)"></span><br>
                <span>将笔触移动到指定的坐标x以及y上</span>
            </p>
            <p class="row">
                当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()
                绘制一些不连续的路径。看一下下面的笑脸例子。
            </p>
            <pre class="code line-numbers language-javascript">
                <code>function draw() {</code>
                <code>  var canvas = document.getElementById('canvas');</code>
                <code>  if (canvas.getContext) {</code>
                <code>      var context = canvas.getContext('2d');</code>
                <code>      context.beginPath();</code>
                <code>      context.arc(75, 75, 50, 0, Math.PI * 2, true); // 绘制</code>
                <code>      context.moveTo(110, 75);</code>
                <code>      context.arc(75, 75, 35, 0, Math.PI, false); // 口(顺时针)</code>
                <code>      context.moveTo(65, 65);</code>
                <code>      context.arc(60, 65, 5, 0, Math.PI * 2, true); // 左眼</code>
                <code>      context.moveTo(95, 65);</code>
                <code>      context.arc(90, 65, 5, 0, Math.PI * 2, true); // 右眼</code>
                <code>      context.stroke();</code>
                <code>  }</code>
                <code>}</code>
            </pre>
            <canvas id="face" width="150" height="150"></canvas>
            <p class="row">
                若想看到连续的线，可以去掉调用moveTo()方法。
            </p>
        </div>

        <!-- 线 -->
        <div>
            <h4><span class="sub-title">线</span></h4>
            <p class="row">绘制直线，需要用到的方法lineTo()</p>
            <p class="row">
                <span class="tag-line normal" data-code="lineTo(x, y)"></span><br>
                <span>绘制一条从当前位置到指定x以及y位置的直线</span>
            </p>
            <p class="row">
                该方法有两个参数：x以及y，代表坐标系中直线结束的点。开始点和之前的绘制路径有关，
                之前路径的结束点就是接下来的开始点，开始点也可以通过moveTo()函数改变。
            </p>
            <p class="row">
                下面的例子绘制了两个三角形，一个是填充的，另一个是描边的。
            </p>
            <pre class="code line-numbers language-javascript">
                <code>function draw() {</code>
                <code>  var canvas = document.getElementById('canvas');</code>
                <code>  if (canvas) {</code>
                <code>      var context = canvas.getContext('2d');</code>
                <code>      // 填充三角形</code>
                <code>      context.beginPath();</code>
                <code>      context.moveTo(25, 25);</code>
                <code>      context.lineTo(105, 25)</code>
                <code>      context.lineTo(25, 105)</code>
                <code>      context.fill();</code>
                <code></code>
                <code>      // 描边三角形</code>
                <code>      context.beginPath();</code>
                <code>      context.moveTo(125, 125);</code>
                <code>      context.lineTo(125, 45);</code>
                <code>      context.lineTo(45, 125);</code>
                <code>      context.closePath();</code>
                <code>      context.stroke();</code>
                <code>  }</code>
                <code>}</code>
            </pre>
            <canvas id="triangles" width="150" height="150"></canvas>
            <p class="row">
                你会注意到填充与描边三角形步骤有所不同。正如上面所提到的，因为路径使用填充(filled)时，
                路径自动闭合，使用描边(stroked)则不会闭合路径。如果没有添加闭合路径closePath()到描述
                三角形函数中，则只绘制了两条线段，并不是一个完整的三角形。
            </p>
        </div>

        <!-- 圆弧 -->
        <div>
            <h4><span class="sub-title">圆弧</span></h4>
            <p class="row">
                绘制圆弧或者圆，我们使用<span class="tag-line normal" data-code="arc()"></span>方法。
                当然可以使用<span class="tag-line normal" data-code="arcTo()"></span>，不过这个的实现
                不是那么可靠，所以不做介绍。
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="arc(x, y, radius, startAngle, endAngle, anticlockwise)"></span><br>
                画一个以(x, y)为圆心的以radius为半径的圆弧(圆)，从startAngle开始到endAngle结束，按照anticlockwise给定的方向(默认为顺时针)
                来生成。
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="arcTo(x1, y1, x2, y2, radius)"></span><br>
                根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。
            </p>
            <p class="row">
                这里详细介绍一下arc方法，该方法有六个参数：x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。
                startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是已x轴为基准。参数anticlockwise
                为一个布尔值。为true时，是逆时针方向，否则为顺时针方向。
            </p>
            <div class="warning">
                <p>
                    <span>注意：arc()函数中的角度单位是弧度，不是度数。</span><br>
                    <span>角度与弧度的js表达式：radians = (Math.PI / 180) * degrees。</span>
                </p>
            </div>
            <p class="row">
                下面绘制了12个不同的角度以及填充的圆弧
            </p>
            <p class="row">
                下面两个for循环，生成圆弧的行列(x, y)坐标。每一段圆弧的开始都调用beginPath()。代码中，
                每个圆弧的参数都是可变的，实际生活中，我们并不需要这样做。
            </p>
            <p class="row">
                x, y坐标是可变的。半径(radius)和开始角度(startAngle)都是固定的。结束角度(endAngle)在
                第一列开始时是180度(半圆)然后没每列增加90度。最后一列形成一个完整的圆。
            </p>
            <p class="row">
                closewise语句作用于第一、三行是顺时针的圆弧，anticlockwise作用于二、四行为逆时针圆弧。
                if语句让一、二描边圆弧，下面两行填充路径。
            </p>
            <div class="warning">
                <p>注意：这个示例所需的画布大小略大于本页面的其他例子：150 * 200像素。</p>
            </div>
            <pre class="code max-width-800 line-numbers language-javascript">
                <code>function draw() {</code>
                <code>  var canvas = document.getElementById('canvas');</code>
                <code>  if (canvas.getContext) {</code>
                <code>      var context = canvas.getContext('2d');</code>
                <code>      for (var i = 0, iLength = 4; i < iLength; i+=1) {</code>
                <code>          for (var j = 0, jLength = 3; j < jLength; j+=1) {</code>
                <code>              var x = 25 + (j * 50); // x 坐标值</code>
                <code>              var y = 25 + (i * 50); // y 坐标值</code>
                <code>              var radius = 20; // 圆弧半径</code>
                <code>              var startAngle = 0; // 开始点</code>
                <code>              var endAngle = Math.PI + (Math.PI * j) / 2 // 结束点</code>
                <code>              var anticlockwise = i % 2 == 0 ? false : true; // 顺时针或逆时针</code>
                <code>              context.arc(x , y, radius, startAngle, endAngle, anticlockwise);</code>
                <code>              if (i > 1) {</code>
                <code>                  context.fill();</code>
                <code>              } else {</code>
                <code>                  context.stroke();</code>
                <code>              }</code>
                <code>          }</code>
                <code>      }</code>
                <code>  }</code>
                <code>}</code>
            </pre>
            <canvas id="circles" width="150" height="200"></canvas>
        </div>

        <!-- 二次贝赛尔曲线和三次贝赛尔曲线 -->
        <div>
            <h4><span class="sub-title">二次贝塞尔曲线和三次贝塞尔曲线</span></h4>
            <p class="row">
                二次贝塞尔曲线和三次贝赛尔曲线都十分有用，一般用来绘制复杂有规律的图形
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="quadraticCurveTo(cp1x, cp1y, x, y)"></span><br>
                <span>绘制二次贝塞尔曲线，cp1x、cp1y为一个控制点，x, y为结束点</span>
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)"></span><br>
                <span>绘制三次贝塞尔曲线，cp1x、cp1y为控制点1，cp2x、cp2y为控制点2，x, y为结束点</span>
            </p>
            <p class="row">
                <img src="../images/Canvas_curves.png" class="pull-right" alt="">
                右边的图能够很好的描述两者的关系，二次贝塞尔曲线有一个结束点(蓝色)以及一个控制点(红色)，
                而三次贝塞尔曲线哟两个控制点，一个结束点，它们都有一个初始位置的点。
            </p>
            <p class="row">
                参数x, y在这两个方法中都是结束点坐标。cp1x、cp1y为坐标中的第一个控制点，cp2x、cp2y为坐标中第二个控制点。
            </p>
            <p class="row">
                使用二次贝塞尔曲线和三次贝塞尔曲线是有一定难度的，因为不同于像AI这种矢量软件，我们所绘制的
                曲线没有直接的视觉反馈。这让绘制复杂的图形十分困难。在下面的例子中，我们会绘制一些简单而有规律的图形。
            </p>

            <h4>二次贝塞尔曲线</h4>
            <pre class="code line-numbers language-javascript">
                <code>function draw() {</code>
                <code>  var canvas = document.getElementById('canvas');</code>
                <code>  if (canvas.getContext) {</code>
                <code>      var context = canvas.getContext('2d');</code>
                <code>      // 二次贝塞尔曲线</code>
                <code>      context.beginPath();</code>
                <code>      context.moveTo(75, 25);</code>
                <code>      context.quadraticCurveTo(25, 25, 25, 62.5);</code>
                <code>      context.quadraticCurveTo(25, 100, 50, 100);</code>
                <code>      context.quadraticCurveTo(50, 120, 30, 125);</code>
                <code>      context.quadraticCurveTo(60, 120, 65, 100);</code>
                <code>      context.quadraticCurveTo(125, 100, 125, 62.5);</code>
                <code>      context.quadraticCurveTo(125, 25, 75, 25);</code>
                <code>      context.stroke();</code>
                <code>  }</code>
                <code>}</code>
            </pre>
            <canvas id="quadratic" width="150" height="150"></canvas>

            <h4>三次贝塞尔曲线</h4>
            <pre class="code line-numbers language-javascript">
                <code>function draw() {</code>
                <code>  var canvas = document.getElementById('2d');</code>
                <code>  if (canvas.getContext) {</code>
                <code>      var context = canvas.getContext('2d');</code>
                <code>      // 三次贝塞尔曲线</code>
                <code>      context.beginPath();</code>
                <code>      context.moveTo(75, 40);</code>
                <code>      context.bezierCurveTo(75, 37, 70, 25, 50, 25);</code>
                <code>      context.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);</code>
                <code>      context.bezierCurveTo(20, 80, 40, 102, 75, 120);</code>
                <code>      context.bezierCurveTo(110, 102, 130, 80, 130, 62.5);</code>
                <code>      context.bezierCurveTo(130, 62.5, 130, 25, 100, 25);</code>
                <code>      context.bezierCurveTo(85, 25, 75, 37, 75, 40);</code>
                <code>      context.fill();</code>
                <code>  }</code>
                <code>}</code>
            </pre>
            <canvas id="bezier" width="150" height="150"></canvas>
        </div>

        <!-- 矩形 -->
        <div>
            <h4><span class="sub-title">矩形</span></h4>
            <p class="row">
                直接在画布上绘制矩形的三个额外方法，rect()方法，将一个矩形路径增加到当前路径上。
            </p>
            <p class="row">
                <span class="tag-line normal" data-code="rect(x, y, width, height)"></span><br>
                绘制一个左上角坐标为(x, y)，宽高为width和height的矩形。
            </p>
            <p class="row">
                当该方法执行的时候，moveTo()方法自动设置坐标参数(0, 0)。也就是说，当前笔触自动重置回默认坐标。
            </p>
            <canvas id="rect" width="150" height="150"></canvas>
        </div>
    </div>

    <script type="text/javascript" src="../common/js/common.js"></script>
    <script type="text/javascript" src="../common/js/prism.js"></script>
    <script type="text/javascript">
        // 绘制三角形 
        function drawTriangle() {
            var canvas = document.getElementById('triangle');
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                context.beginPath();
                context.moveTo(75, 75);
                context.lineTo(100, 50);
                context.lineTo(100, 100);
                context.fill();
            }
        }
        drawTriangle();

        // 绘制人脸
        function drawFace() {
            var canvas = document.getElementById('face');
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                context.beginPath();
                context.arc(75, 75, 50, 0, Math.PI * 2, true); // 绘制
                context.moveTo(110, 75);
                context.arc(75, 75, 35, 0, Math.PI, false); // 口(顺时针)
                context.moveTo(65, 65);
                context.arc(60, 65, 5, 0, Math.PI * 2, true); // 左眼
                context.moveTo(95, 65);
                context.arc(90, 65, 5, 0, Math.PI * 2, true); // 右眼
                context.stroke();
            }
        }
        drawFace();

        // 绘制两个三角形
        function drawTriangles() {
            var canvas = document.getElementById('triangles');
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                // 填充三角形
                context.beginPath();
                context.moveTo(25, 25);
                context.lineTo(105, 25);
                context.lineTo(25, 105);
                context.fill();

                // 描边三角形
                context.beginPath();
                context.moveTo(125, 125);
                context.lineTo(125, 45);
                context.lineTo(45, 125);
                context.closePath();
                context.stroke();
            }
        }
        drawTriangles();

        // 绘制多个圆
        function drawCircles() {
            var canvas = document.getElementById('circles');
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                for (var i = 0, iLength = 4; i < iLength; i+=1) {
                    for (var j = 0, jLength = 3; j < jLength; j+=1) {
                        context.beginPath();
                        var x = 25 + (j * 50); // x 坐标值
                        var y = 25 + (i * 50); // y 坐标值
                        var radius = 20; // 半径
                        var startAngle = 0; // 开始角度
                        var endAngle = Math.PI + (Math.PI * j) / 2; // 结束角度，初始180度，每次加90度，最后一次为2 * PI(绘制完整圆)
                        var anticlockwise = i % 2 == 0 ? false : true;
                        context.arc(x, y, radius, startAngle, endAngle, anticlockwise);
                        if (i > 1) {
                            context.fill();
                        } else {
                            context.stroke();
                        }
                    }
                }
            }
        }
        drawCircles();

        // 绘制二次贝塞尔曲线
        function drawQuadratic() {
            var canvas = document.getElementById('quadratic');
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                // 绘制二次贝塞尔曲线
                context.beginPath();
                context.moveTo(75, 25);
                context.quadraticCurveTo(25, 25, 25, 62.5);
                context.quadraticCurveTo(25, 100, 50, 100);
                context.quadraticCurveTo(50, 120, 30, 125);
                context.quadraticCurveTo(60, 120, 65, 100);
                context.quadraticCurveTo(125, 100, 125, 62.5);
                context.quadraticCurveTo(125, 25, 75, 25);
                context.stroke();
            }
        }
        drawQuadratic();

        // 绘制三次贝塞尔曲线
        function drawBezier() {
            var canvas = document.getElementById('bezier');
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                // 绘制三次贝塞尔曲线
                context.beginPath();
                context.moveTo(75, 40);
                context.bezierCurveTo(75, 37, 70, 25, 50, 25);
                context.bezierCurveTo(20, 25, 20, 62.5, 20, 62.5);
                context.bezierCurveTo(20, 80, 40, 102, 75, 120);
                context.bezierCurveTo(110, 102, 130, 80, 130, 62.5);
                context.bezierCurveTo(130, 62.5, 130, 25, 100, 25);
                context.bezierCurveTo(85, 25, 75, 37, 75, 40);
                context.fill();
            }
        }
        drawBezier();

        // 绘制矩形
        function drawRect() {
            var canvas = document.getElementById('rect');
            if (canvas.getContext) {
                var context = canvas.getContext('2d');
                context.beginPath();
                context.rect(25, 25, 60, 60);
                context.fillStyle = 'rgba(255, 0, 0, .6)';
                context.lineTo(15, 50);
                context.lineTo(25, 50);
                context.lineTo(85 ,85);
                context.fill();
            }
        }
        drawRect();
    </script>
</body>
</html>